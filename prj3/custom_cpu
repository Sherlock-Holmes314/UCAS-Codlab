`timescale 10ns / 1ns

module custom_cpu(
	input         clk,
	input         rst,

	//Instruction request channel
	output reg    [31:0] PC,
	output        Inst_Req_Valid,
	input         Inst_Req_Ready,

	//Instruction response channel
	input  [31:0] Instruction,
	input         Inst_Valid,
	output        Inst_Ready,

	//Memory request channel
	output [31:0] Address,
	output        MemWrite,
	output [31:0] Write_data,
	output [ 3:0] Write_strb,
	output        MemRead,
	input         Mem_Req_Ready,

	//Memory data response channel
	input  [31:0] Read_data,
	input         Read_data_Valid,
	output        Read_data_Ready,

	input         intr,

	output [31:0] cpu_perf_cnt_0,
	output [31:0] cpu_perf_cnt_1,
	output [31:0] cpu_perf_cnt_2,
	output [31:0] cpu_perf_cnt_3,
	output [31:0] cpu_perf_cnt_4,
	output [31:0] cpu_perf_cnt_5,
	output [31:0] cpu_perf_cnt_6,
	output [31:0] cpu_perf_cnt_7,
	output [31:0] cpu_perf_cnt_8,
	output [31:0] cpu_perf_cnt_9,
	output [31:0] cpu_perf_cnt_10,
	output [31:0] cpu_perf_cnt_11,
	output [31:0] cpu_perf_cnt_12,
	output [31:0] cpu_perf_cnt_13,
	output [31:0] cpu_perf_cnt_14,
	output [31:0] cpu_perf_cnt_15,

	output [69:0] inst_retire
);

/* The following signal is leveraged for behavioral simulation, 
* which is delivered to testbench.
*
* STUDENTS MUST CONTROL LOGICAL BEHAVIORS of THIS SIGNAL.
*
* inst_retired (70-bit): detailed information of the retired instruction,
* mainly including (in order) 
* { 
*   reg_file write-back enable  (69:69,  1-bit),
*   reg_file write-back address (68:64,  5-bit), 
*   reg_file write-back data    (63:32, 32-bit),  
*   retired PC                  (31: 0, 32-bit)
* }
*
*/
	assign inst_retire = {wen,waddr,wdata,PC};
	reg [31:0] Instruction_reg;
	reg [31:0] Read_data_reg;

	//指令数据
	wire			  RF_wen;
	wire [4:0]		  RF_waddr;
	wire [31:0]		  RF_wdata;
	wire [5:0]              opcode;
	wire [4:0]              rs;
	wire [4:0]              rt;
	wire [4:0]              rd;
	wire [4:0]              shamt;
	wire [5:0]              func;
	wire [15:0]             immediate;
	wire [25:0]             distance;   
	wire [31:0]             next;
	wire [31:0]             target; 

	assign next = PC + 4;
	assign opcode = Instruction_reg[31:26];
	assign rs = Instruction_reg[25:21];
	assign rt = Instruction_reg[20:16];
	assign rd = Instruction_reg[15:11];
	assign shamt = Instruction_reg[10:6];
	assign func = Instruction_reg[5:0];
	assign immediate = Instruction_reg[15:0];
	assign distance = Instruction_reg[25:0];

	//R-type数据
	wire         wen_R;
	wire [31:0]  wdata_R;
	wire [31:0]  A_alu_R;
	wire [31:0]  B_alu_R;
	wire [ 2:0]  ALUop_R;

	//I-type数据
	wire [31:0]  wdata_IC;
	wire [31:0]  A_alu_I;
	wire [31:0]  B_alu_I;
	wire [ 2:0]  ALUop_I;

	//J
	wire [31:0]  wdata_J;
	wire [31:0] target_J;

	//load
	wire [31:0]     A_alu_LS;
	wire [31:0]     B_alu_LS;
	wire [ 2:0]     ALUop_LS;
	wire [31:0]     Read_data_1;
	wire [31:0]     Read_data_2;
	wire [ 2:0]     rsign;
	wire [31:0]     wdata_L;
	wire [ 7:0]     read_b;
	wire [15:0]     read_h;

	//store
	wire [ 3:0]     wtrb1;
	wire [ 3:0]     wtrb2;
	wire [31:0]     Write_data_1; 
	wire [31:0]     Write_data_2; 
	wire [ 2:0]     wsign2;
	wire [ 3:0]     wsign1;
	wire [31:0]     write_b;
	wire [31:0]     write_h;

	//branch
	wire [31:0]     A_alu_b;
	wire [31:0]     B_alu_b;
	wire [ 2:0]     ALUop_b;
	wire [31:0]     target_b;

	//regimm
	wire [31:0]     target_RE;
	wire [31:0]     A_alu_RE;
	wire [31:0]     B_alu_RE;
	wire [ 2:0]     ALUop_RE;

	//主alu 数据
	wire [31:0]  A_alu;
	wire [31:0]  B_alu;
	wire [ 2:0]  ALUop;
	wire         Overflow;
	wire         CarryOut;
	wire         Zero;
	wire [31:0]  Result_alu;

	assign A_alu = ({32{~(opcode[5]|opcode[4]|opcode[3]|opcode[2]|opcode[1]|opcode[0])}} & A_alu_R )
			| ({32{~opcode[5] & ~opcode[4] & opcode[3]}} & A_alu_I)
			| ({32{~(opcode[5]|opcode[4]|opcode[3]|opcode[2]|opcode[1]|~opcode[0])}} & A_alu_RE)
			| ({32{opcode[5]}} & A_alu_LS)
			| ({32{~opcode[5] & ~opcode[4] & ~opcode[3] & opcode[2]}} & A_alu_b);
	assign B_alu =({32{~(opcode[5]|opcode[4]|opcode[3]|opcode[2]|opcode[1]|opcode[0])}} & B_alu_R )
			| ({32{~opcode[5] & ~opcode[4] & opcode[3]}} & B_alu_I)
			| ({32{~(opcode[5]|opcode[4]|opcode[3]|opcode[2]|opcode[1]|~opcode[0])}} & B_alu_RE)
			| ({32{opcode[5]}} & B_alu_LS)
			| ({32{~opcode[5] & ~opcode[4] & ~opcode[3] & opcode[2]}} & B_alu_b);
	assign ALUop =({3{~(opcode[5]|opcode[4]|opcode[3]|opcode[2]|opcode[1]|opcode[0])}} & ALUop_R )
			| ({3{~opcode[5] & ~opcode[4] & opcode[3]}} & ALUop_I)
			| ({3{~(opcode[5]|opcode[4]|opcode[3]|opcode[2]|opcode[1]|~opcode[0])}} & ALUop_RE)
			| ({3{opcode[5]}} & ALUop_LS)
			| ({3{~opcode[5] & ~opcode[4] & ~opcode[3] & opcode[2]}} & ALUop_b);


	//rf数据
	wire [4:0]  waddr;
	wire [4:0]  raddr1;
	wire [4:0]  raddr2;
	wire        wen;
	wire        wen1;
	wire [31:0] wdata;
	wire [31:0] rdata1;
	wire [31:0] rdata2;

	assign RF_waddr = waddr;
	assign RF_wdata = wdata;

	assign wen1 = (opcode==6'b0) ? wen_R : 
			(opcode==6'b000001) ? 0 :
			(opcode==6'b000010) ? 0 :
			(opcode[5:2]==4'b0001)? 0 : 
			({opcode[5],opcode[3]}==2'b11) ? 0 : 1;
	assign waddr = (opcode==6'b0) ? rd : 
			(opcode==6'b000011) ? 5'b11111 : rt;
	assign wdata = ({32{~(opcode[5]|opcode[4]|opcode[3]|opcode[2]|opcode[1]|opcode[0])}} & wdata_R )
			| ({32{~opcode[5] & ~opcode[4] & opcode[3]}} & wdata_IC)
			| ({32{~(opcode[5]|opcode[4]|opcode[3]|opcode[2]|~opcode[1]|~opcode[0])}} & wdata_J )
			| ({32{opcode[5] & ~opcode[3]}} & wdata_L);

	assign raddr1 = rs; 
	assign raddr2 = rt;

	//shifter数据. 只有R-type用
	wire [31:0] A_shifter;
	wire [ 4:0] B_shifter;   
	wire [ 1:0] Shiftop; 
	wire [31:0] Result_shifter;

	//R-type opcode=6'b0
	assign wen_R = (func[5]==1'b1 || func[5:3]== 3'b0) ? 1 :
			({func[5:3],func[1]} == 4'b0010 ) ? ((func[0] == 1'b1) ? 1 : 0 ) :
			((rdata2==32'b0) && (func[0]==0))  ? 1 :
			((rdata2!=32'b0) && (func[0]!=0))  ? 1 : 0;
	assign wdata_R = ({32{func[5]}} & Result_alu)
			| ({32{~(func[5] | func[4] | func[3])}} & Result_shifter)
			| ({32{~(func[5] | func[4] | ~func[3] | func[1])}} & PC_Writeback_reg)
			| ({32{~(func[5] | func[4] | ~func[3] | ~func[1])}} & rdata1);
	assign ALUop_R = ({3{~func[3] & ~func[2]}} & {func[1],2'b10})
			| ({3{~func[3] & func[2]}} & {func[1],1'b0,func[0]})
			| ({3{func[3] & ~func[2]}} & {~func[0],2'b11});
	assign A_alu_R = rdata1;
	assign B_alu_R = rdata2;          
	assign Shiftop = func[1:0];
	assign A_shifter = rdata2;
	assign B_shifter = func[2] ? rdata1[4:0] : shamt;        

	//I-type 计算
	assign ALUop_I = ({3{~opcode[2] & ~opcode[1]}} & {opcode[1],2'b10})
			| ({3{opcode[2]}} & {opcode[1],1'b0,opcode[0]})
			| ({3{~opcode[2] & opcode[1]}} & {~opcode[0],2'b11});

	assign A_alu_I = rdata1;
	assign B_alu_I = (opcode[2:0]==3'b001 || opcode[2:0]==3'b010) ? 
				{{16{immediate[15]}},immediate} : {16'b0,immediate};
	assign wdata_IC = (opcode[3]&opcode[2]&opcode[1]&opcode[0])?
				{immediate,16'b0} : Result_alu;

	//load
	assign Address = Result_alu & {{30{1'b1}},2'b0};
	assign A_alu_LS = rdata1;
	assign B_alu_LS = {{16{immediate[15]}},immediate};
	assign ALUop_LS = 3'b010; //
	assign Read_data_1 = ({32{~opcode[1] & ~opcode[0] & opcode[2]}} & {24'b0,read_b})
				| ({32{~opcode[1] & ~opcode[0] & ~opcode[2]}} & {{24{read_b[7]}},read_b})
				| ({32{~opcode[1] & opcode[0] & opcode[2]}} & {16'b0,read_h[15:0]})
				| ({32{~opcode[1] & opcode[0] & ~opcode[2]}} & {{16{read_h[15]}},read_h[15:0]})
				| ({32{opcode[1] & opcode[0]}} & Read_data_reg);
	assign read_b = ({8{~Result_alu[1] & ~Result_alu[0]}} & Read_data_reg[7:0])
			| ({8{~Result_alu[1] & Result_alu[0]}} & Read_data_reg[15:8])
			| ({8{Result_alu[1] & ~Result_alu[0]}} & Read_data_reg[23:16])
			| ({8{Result_alu[1] & Result_alu[0]}} & Read_data_reg[31:24]);
	assign read_h = ({16{~Result_alu[1] & ~Result_alu[0]}} & Read_data_reg[15:0])
			| ({16{Result_alu[1] & ~Result_alu[0]}} & Read_data_reg[31:16]);
	assign rsign = {opcode[2],Result_alu[1:0]};
	assign Read_data_2 = ({32{~rsign[2] & ~rsign[1] & ~rsign[0]}} & {Read_data_reg[7:0],rdata2[23:0]})
				| ({32{~rsign[2] & ~rsign[1] & rsign[0]}} & {Read_data_reg[15:0],rdata2[15:0]})
				| ({32{~rsign[2] & rsign[1] & ~rsign[0]}} & {Read_data_reg[23:0],rdata2[7:0]})
				| (({32{~rsign[2] & rsign[1] & rsign[0]}} | {32{rsign[2] & ~rsign[1] & ~rsign[0]}}) & Read_data_reg)
				| ({32{rsign[2] & ~rsign[1] & rsign[0]}} & {rdata2[31:24],Read_data_reg[31:8]})
				| ({32{rsign[2] & rsign[1] & ~rsign[0]}} & {rdata2[31:16],Read_data_reg[31:16]})
				| ({32{rsign[2] & rsign[1] & rsign[0]}} & {rdata2[31:8],Read_data_reg[31:24]});
	assign wdata_L = (opcode[1:0]==2'b10) ? Read_data_2 : Read_data_1;

	//write 
	assign wsign1 = {Result_alu[1:0],opcode[1:0]};
	assign wtrb1 = ({4{~wsign1[3] & ~wsign1[2] & ~wsign1[1] & ~wsign1[0]}} & 4'b0001)
			| ({4{~wsign1[3] & wsign1[2] & ~wsign1[1] & ~wsign1[0]}} & 4'b0010)
			| ({4{wsign1[3] & ~wsign1[2] & ~wsign1[1] & ~wsign1[0]}} & 4'b0100)
			| ({4{wsign1[3] & wsign1[2] & ~wsign1[1] & ~wsign1[0]}} & 4'b1000)
			| ({4{~wsign1[3] & ~wsign1[2] & ~wsign1[1] & wsign1[0]}} & 4'b0011)
			| ({4{wsign1[3] & ~wsign1[2] & ~wsign1[1] & wsign1[0]}} & 4'b1100)
			| ({4{~wsign1[3] & ~wsign1[2] & wsign1[1] & wsign1[0]}} & 4'b1111);

	assign Write_data_1 = (opcode[1:0]==2'b00) ? write_b:
				(opcode[1:0]==2'b01) ? write_h : rdata2;
	assign write_b = (wsign1==4'b0000) ? {24'b0,rdata2[7:0]} :
			(wsign1==4'b0100) ? {16'b0,rdata2[7:0],8'b0} :
			(wsign1==4'b1000) ? {8'b0,rdata2[7:0],16'b0} : {rdata2[7:0],24'b0};
	assign write_h = (wsign1==4'b0001) ? {16'b0,rdata2[15:0]} : {rdata2[15:0],16'b0};
	assign wsign2 = {opcode[2],Result_alu[1:0]};
	assign Write_data_2 = ({32{~wsign2[2] & ~wsign2[1] & ~wsign2[0]}} & {24'b0,rdata2[31:24]})
				| ({32{~wsign2[2] & ~wsign2[1] & wsign2[0]}} & {16'b0,rdata2[31:16]})
				| ({32{~wsign2[2] & wsign2[1] & ~wsign2[0]}} & {8'b0,rdata2[31:8]})
				| (({32{~wsign2[2] & wsign2[1] & wsign2[0]}} | {32{wsign2[2] & ~wsign2[1] & ~wsign2[0]}}) & rdata2)
				| ({32{wsign2[2] & ~wsign2[1] & wsign2[0]}} & {rdata2[23:0],8'b0})
				| ({32{wsign2[2] & wsign2[1] & ~wsign2[0]}} & {rdata2[15:0],16'b0})
				| ({32{wsign2[2] & wsign2[1] & wsign2[0]}} & {rdata2[7:0],24'b0});
	assign wtrb2 = ({4{~wsign2[2] & ~wsign2[1] & ~wsign2[0]}} & 4'b0001)
			| ({4{~wsign2[2] & ~wsign2[1] & wsign2[0]}} & 4'b0011)
			| ({4{~wsign2[2] & wsign2[1] & ~wsign2[0]}} & 4'b0111)
			| (({4{~wsign2[2] & wsign2[1] & wsign2[0]}} | {32{wsign2[2] & ~wsign2[1] & ~wsign2[0]}}) & 4'b1111)
			| ({4{wsign2[2] & ~wsign2[1] & wsign2[0]}} & 4'b1110)
			| ({4{wsign2[2] & wsign2[1] & ~wsign2[0]}} & 4'b1100)
			| ({4{wsign2[2] & wsign2[1] & wsign2[0]}} & 4'b1000);
	assign Write_strb = (opcode[1:0]==2'b10) ? wtrb2 : wtrb1;
	assign Write_data = (opcode[1:0]==2'b10) ? Write_data_2: Write_data_1;

	//branch    
	assign target_b = {{16{immediate[15]}},immediate}<<2;
	assign ALUop_b = (opcode[1:0]==2'b00 || opcode[1:0]==2'b01) ? 3'b110 : 3'b111 ;//SLT 
	assign A_alu_b = rdata1;
	assign B_alu_b = (opcode[1:0]==2'b00 || opcode[1:0]==2'b01) ? rdata2 : 32'b0;

	//REGIMM  opcode=000001  要用alu吗
	assign target_RE = {{16{immediate[15]}},immediate}<<2;
	assign ALUop_RE = 3'b111 ;
	assign A_alu_RE = rdata1;
	assign B_alu_RE = 0; 

	//J   
	assign target_J = {next[31:28],distance,2'b0}; 
	assign wdata_J = PC_Writeback_reg;


	//状态定义
	localparam INIT = 9'b000000001; 
	localparam   IF = 9'b000000010;
	localparam   IW = 9'b000000100;
	localparam   ID = 9'b000001000;
	localparam   EX = 9'b000010000;
	localparam   ST = 9'b000100000;
	localparam   LD = 9'b001000000;
	localparam  RDW = 9'b010000000;
	localparam   WB = 9'b100000000;

	reg [8:0] current_state;
	reg [8:0] next_state;

	//PART1
	always @ (posedge clk)begin
		if(rst==1'b1)
			current_state <= INIT;
		else
			current_state <= next_state;
	end

	//PART2
	wire nopif;
	assign nopif = current_state[3] & (Instruction_reg[31:0] == 32'b0); //ID时判断
	always @ (*)begin//为什么用阻塞赋值
		case(current_state)
			INIT:   next_state = IF;
			IF:begin
				if(Inst_Req_Ready==1)
					next_state = IW;
				else 
					next_state = IF;
			end
			IW:begin
				if(Inst_Valid==1)
					next_state = ID;
				else
					next_state = IW;
			end
			ID:begin
				if(nopif)
					next_state = IF;
				else
					next_state = EX;
			end
			EX:begin
				if(opcode==6'b0 || opcode[5:3]==3'b001 || opcode==6'b000011)
					next_state = WB;
				else if(opcode==6'b000001 || opcode[5:2]==4'b0001 || opcode==6'b000010)
					next_state = IF;
				else if(opcode[5] & opcode[3])
					next_state = ST;
				else if(opcode[5] & ~opcode[3])
					next_state = LD;
				else
					next_state = INIT;
			end
			WB:     next_state = IF;
			ST:begin
				if(Mem_Req_Ready == 1)
					next_state = IF;
				else
					next_state = ST;
			end
			LD:begin
				if(Mem_Req_Ready == 1)
					next_state = RDW;
				else
					next_state = LD;
			end
			RDW:begin
				if(Read_data_Valid == 1)
					next_state = WB;
				else
					next_state = RDW;
			end
			default: next_state = INIT;
		endcase
	end


	//PART3

	assign Inst_Req_Valid = current_state[1];   //current_state == IF
	assign Inst_Ready = current_state[2] | current_state[0];     //IW or INIT
	assign Read_data_Ready = current_state[7] | current_state[0];   //LD or INIT
	assign MemWrite = current_state[5];
	assign MemRead = current_state[6];
	assign wen = current_state[8] & wen1;
	assign RF_wen = wen;


	//PC
	assign target = (opcode[5:1] == 5'b00001) ? target_J :
			(opcode == 6'b0 && {func[5:3],func[1]} == 4'b0010) ? rdata1 :
			(opcode==6'b000001 && ((rt[0]==0 && Result_alu==1) || (rt[0]==1 && Result_alu==0)) ) ? (target_RE + next) :
			(opcode[5:2]==4'b0001 && 
			((opcode[1:0]==2'b00 && Zero==1) || (opcode[1:0]==2'b01 && Zero==0)  || (opcode[1:0]==2'b10 && (Result_alu==1 || rdata1==32'b0)) || (opcode[1:0]==2'b11 && (Result_alu==0 && rdata1!=32'b0)))) ? (target_b + next) :
			next;
	always@(posedge clk)begin
		if(current_state == INIT)  //high is effective!
			PC <= 0;
		else if(current_state[4] | nopif ) // current_state == EX or nop
			PC <= target;
		else
			PC <= PC;
	end

	//pc write 
	reg [31:0] PC_Writeback_reg;
	always @ (posedge clk)begin
		if(current_state[3])
			PC_Writeback_reg <= PC + 8;
		else
			PC_Writeback_reg <= PC_Writeback_reg;
	end

	//Instruction reg
	always@(posedge clk)begin
		if(Inst_Valid)
			Instruction_reg <= Instruction;
		else
			Instruction_reg <= Instruction_reg;
	end

	//Read_data reg
	always@(posedge clk)begin
		if(Read_data_Valid)
			Read_data_reg <= Read_data;
		else
			Read_data_reg <= Read_data_reg;
	end

	//操作数 reg
	reg [31:0] A_reg;
	always@(posedge clk)begin
		if(current_state[3])begin  //current_state == ID
		        if(opcode == 6'b0 && func[5:3] == 3'b0)
			        A_reg <= A_shifter;
			else
			        A_reg <= A_alu;
		end
	end
	reg [31:0] B_reg;
	always@(posedge clk)begin
		if(current_state[3])begin  //current_state == ID
		        if(opcode == 6'b0 && func[5:3] == 3'b0)
			        B_reg <= {27'b0,B_shifter};
			else
			        B_reg <= B_alu;
		end
	end
		
	//周期计数器
	reg [31:0] cycle_cnt;
	assign cpu_perf_cnt_0 = cycle_cnt;
	always@(posedge clk)begin
		if(rst == 1'b1)
			cycle_cnt <= 32'b0;
		else
			cycle_cnt <= cycle_cnt + 32'b1;
	end

	//指令数计数器
	reg [31:0] instruction_cnt;
	assign cpu_perf_cnt_1 = instruction_cnt;
	always @ (posedge clk)begin
		if(rst == 1'b1)
		        instruction_cnt <= 32'b0;
		else if(current_state[3])  //译码，ID
		        instruction_cnt <= instruction_cnt + 32'b1;
		else
		        instruction_cnt <= instruction_cnt;
	end

	//访存次数计数器
	reg [31:0] WL_cnt;
	assign cpu_perf_cnt_2 = WL_cnt;
	reg signWL;
	always @ (posedge clk)begin
		if(rst == 1'b1)
		        WL_cnt <= 32'b0;
		else if((current_state == ST || current_state == LD) & signWL)  
		        WL_cnt <= WL_cnt + 32'b1;
		else
		        WL_cnt <= WL_cnt;
	end
	always @ (posedge clk)begin
                if(current_state == ST || current_state == LD)  
		        signWL <= 1'b0;
		else
		        signWL <= 1'b1;
	end

	//访存延时
	reg [31:0] WL_delay;
	assign cpu_perf_cnt_3 = WL_delay;
	always @ (posedge clk)begin
		if(rst == 1'b1)
		        WL_delay <= 32'b0;
		else if((current_state == ST || current_state == LD) || (current_state == RDW))  
		        WL_delay <= WL_delay + 32'b1;
		else
		        WL_delay <= WL_delay;
	end

	//alu实例化
	alu R_alu(
		.A        (A_reg),
		.B        (B_reg),
		.ALUop    (ALUop),
		.Overflow (Overflow),
		.CarryOut (CarryOut),
		.Zero     (Zero),
		.Result   (Result_alu)
	);

	//rf实例化
	reg_file R_reg_file(
		.waddr    (waddr),
		.raddr1   (raddr1),
		.raddr2   (raddr2),
		.wen      (wen),
		.wdata    (wdata),
		.rdata1   (rdata1),
		.rdata2   (rdata2),
		.clk      (clk)
	);

	//shifter实例化
	shifter R_shifter(
		.A        (A_reg),
		.B        (B_reg[4:0]),
		.Shiftop  (Shiftop),
		.Result   (Result_shifter)
	);
endmodule


